import { mkdir, writeFile } from 'node:fs/promises'
import { dirname } from 'node:path'
import { TranslationContract } from '../contract.js'

interface SwiftEnumCase {
  rawValue: string
  caseName: string
}

/**
 * Options for Swift target generation.
 */
export interface GenerateSwiftTargetOptions {
  /**
   * Canonical translation contract used as source of truth.
   */
  contract: TranslationContract<string>
  /**
   * Absolute output path for generated Swift file.
   */
  outputPath: string
}

/**
 * Result for generated Swift target artifacts.
 */
export interface GenerateSwiftTargetResult {
  /**
   * Absolute output path for generated Swift file.
   */
  outputPath: string
}

const toSwiftIdentifier = (value: string): string => {
  const normalized = value
    .trim()
    .replace(/[^A-Za-z0-9]+/g, ' ')
    .split(' ')
    .filter((part) => part.length > 0)
    .map((part) => part.toLowerCase())

  if (normalized.length === 0) {
    return 'value'
  }

  const combined = normalized
    .map((part, index) =>
      index === 0 ? part : `${part.slice(0, 1).toUpperCase()}${part.slice(1)}`
    )
    .join('')

  if (/^[0-9]/.test(combined)) {
    return `_${combined}`
  }

  return combined
}

const toUniqueSwiftCases = (values: ReadonlyArray<string>): ReadonlyArray<SwiftEnumCase> => {
  const usedNames = new Map<string, number>()

  return values.map((rawValue) => {
    const baseName = toSwiftIdentifier(rawValue)
    const currentCount = usedNames.get(baseName) ?? 0
    usedNames.set(baseName, currentCount + 1)
    const caseName = currentCount === 0 ? baseName : `${baseName}_${currentCount + 1}`

    return {
      rawValue,
      caseName,
    }
  })
}

const toSwiftStringLiteral = (value: string): string =>
  `"${value.replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`

const toSwiftCaseDeclaration = (caseName: string): string => `\`${caseName}\``

const toSwiftCaseReference = (caseName: string): string => `.\`${caseName}\``

const toSwiftLocaleByLanguageSource = (
  entries: ReadonlyArray<{ key: string; value: string }>
): string => {
  if (entries.length === 0) {
    return '[:]'
  }

  const lines = entries.map(
    (entry) => `      ${toSwiftCaseReference(entry.key)}: ${toSwiftStringLiteral(entry.value)}`
  )
  return `[
${lines.join(',\n')}
  ]`
}

const toSwiftSource = (contract: TranslationContract<string>): string => {
  const languageCases = toUniqueSwiftCases(contract.languages)
  const keyCases = toUniqueSwiftCases(contract.entries.map((entry) => entry.key))
  const categoryCases = toUniqueSwiftCases(
    Array.from(new Set(contract.entries.map((entry) => entry.category)))
  )
  const languageByRawValue = new Map(
    languageCases.map((languageCase) => [languageCase.rawValue, languageCase.caseName])
  )

  const sourceLanguageCase = languageByRawValue.get(contract.sourceLanguage)
  if (!sourceLanguageCase) {
    throw new Error(
      `Swift generation failed: source language "${contract.sourceLanguage}" is not declared in contract languages.`
    )
  }

  const localeEntries = Object.entries(contract.localeByLanguage)
    .map(([language, locale]) => {
      const caseName = languageByRawValue.get(language)
      if (!caseName) {
        return null
      }
      return {
        key: caseName,
        value: locale,
      }
    })
    .filter((entry): entry is { key: string; value: string } => entry !== null)

  const languageEnumCases = languageCases
    .map(
      (languageCase) =>
        `  case ${toSwiftCaseDeclaration(languageCase.caseName)} = ${toSwiftStringLiteral(languageCase.rawValue)}`
    )
    .join('\n')
  const keyEnumCases = keyCases
    .map(
      (keyCase) =>
        `  case ${toSwiftCaseDeclaration(keyCase.caseName)} = ${toSwiftStringLiteral(keyCase.rawValue)}`
    )
    .join('\n')
  const categoryEnumCases = categoryCases
    .map(
      (categoryCase) =>
        `  case ${toSwiftCaseDeclaration(categoryCase.caseName)} = ${toSwiftStringLiteral(categoryCase.rawValue)}`
    )
    .join('\n')
  const localeByLanguageSource = toSwiftLocaleByLanguageSource(localeEntries)

  return `// This file is generated by typekit-i18n. Do not edit manually.
import Foundation

public enum TranslationLanguage: String, CaseIterable, Sendable {
${languageEnumCases}
}

public enum TranslationKey: String, CaseIterable, Sendable {
${keyEnumCases}
}

public enum TranslationCategory: String, CaseIterable, Sendable {
${categoryEnumCases}
}

public enum TranslationPlaceholderValue: Sendable {
  case string(String)
  case number(Double)
  case boolean(Bool)
  case date(Date)

  var bridgeValue: Any {
    switch self {
    case let .string(value):
      return value
    case let .number(value):
      return value
    case let .boolean(value):
      return value
    case let .date(value):
      return value.timeIntervalSince1970 * 1000.0
    }
  }
}

public struct TranslationPlaceholder: Sendable {
  public let key: String
  public let value: TranslationPlaceholderValue

  public init(key: String, value: TranslationPlaceholderValue) {
    self.key = key
    self.value = value
  }
}

public enum TypekitSwiftBridgeError: Error {
  case missingRuntimeFunction(String)
  case runtimeExecutionFailed(String)
  case missingTranslation(String)
  case invalidRuntimeResult
}

public protocol TranslationRuntimeBridge {
  func translate(
    key: String,
    language: String,
    placeholders: [TranslationPlaceholder]
  ) throws -> String
}

public final class ClosureTranslationRuntimeBridge: TranslationRuntimeBridge {
  private let handler: @Sendable (String, String, [TranslationPlaceholder]) throws -> String

  public init(handler: @escaping @Sendable (String, String, [TranslationPlaceholder]) throws -> String) {
    self.handler = handler
  }

  public func translate(
    key: String,
    language: String,
    placeholders: [TranslationPlaceholder]
  ) throws -> String {
    try handler(key, language, placeholders)
  }
}

public enum TranslationContractInfo {
  public static let sourceLanguage: TranslationLanguage = ${toSwiftCaseReference(sourceLanguageCase)}
  public static let languages: [TranslationLanguage] = TranslationLanguage.allCases
  public static let categories: [TranslationCategory] = TranslationCategory.allCases
  public static let localeByLanguage: [TranslationLanguage: String] = ${localeByLanguageSource}
}

public final class TypekitTranslator {
  public let defaultLanguage: TranslationLanguage
  private let bridge: TranslationRuntimeBridge
  private var language: TranslationLanguage

  public init(
    bridge: TranslationRuntimeBridge,
    defaultLanguage: TranslationLanguage = TranslationContractInfo.sourceLanguage,
    language: TranslationLanguage? = nil
  ) {
    self.bridge = bridge
    self.defaultLanguage = defaultLanguage
    self.language = language ?? defaultLanguage
  }

  @discardableResult
  public func setLanguage(_ language: TranslationLanguage) -> TypekitTranslator {
    self.language = language
    return self
  }

  public func getLanguage() -> TranslationLanguage {
    language
  }

  public func translate(
    _ key: TranslationKey,
    language: TranslationLanguage? = nil,
    placeholders: [TranslationPlaceholder] = []
  ) throws -> String {
    let resolvedLanguage = language ?? self.language
    return try bridge.translate(
      key: key.rawValue,
      language: resolvedLanguage.rawValue,
      placeholders: placeholders
    )
  }

  public func translate(
    in category: TranslationCategory,
    _ key: TranslationKey,
    language: TranslationLanguage? = nil,
    placeholders: [TranslationPlaceholder] = []
  ) throws -> String {
    _ = category
    return try translate(key, language: language, placeholders: placeholders)
  }
}

#if canImport(JavaScriptCore)
import JavaScriptCore

public final class JavaScriptCoreTranslationRuntimeBridge: TranslationRuntimeBridge {
  private let context: JSContext
  private let functionName: String

  public init(context: JSContext, functionName: String = "__typekitTranslate") {
    self.context = context
    self.functionName = functionName
  }

  public func translate(
    key: String,
    language: String,
    placeholders: [TranslationPlaceholder]
  ) throws -> String {
    guard let function = context.objectForKeyedSubscript(functionName), !function.isUndefined else {
      throw TypekitSwiftBridgeError.missingRuntimeFunction(functionName)
    }

    let placeholderPayload = placeholders.reduce(into: [String: Any]()) { partialResult, placeholder in
      partialResult[placeholder.key] = placeholder.value.bridgeValue
    }

    let payload: [String: Any] = [
      "key": key,
      "language": language,
      "placeholders": placeholderPayload,
    ]

    guard let result = function.call(withArguments: [payload]) else {
      throw TypekitSwiftBridgeError.runtimeExecutionFailed("runtime function did not return a value")
    }

    if result.isString, let text = result.toString() {
      return text
    }

    if result.isObject,
      let object = result.toDictionary() {
      if let missingReason = object["missingReason"] as? String {
        throw TypekitSwiftBridgeError.missingTranslation(missingReason)
      }
      if let text = object["value"] as? String {
        return text
      }
    }

    throw TypekitSwiftBridgeError.invalidRuntimeResult
  }
}
#endif
`
}

/**
 * Generates Swift artifacts from canonical translation contract.
 *
 * @param options Swift target generation options.
 * @returns Generated Swift output path.
 */
export const generateSwiftTarget = async (
  options: GenerateSwiftTargetOptions
): Promise<GenerateSwiftTargetResult> => {
  await mkdir(dirname(options.outputPath), { recursive: true })
  await writeFile(options.outputPath, toSwiftSource(options.contract), 'utf-8')

  return {
    outputPath: options.outputPath,
  }
}
