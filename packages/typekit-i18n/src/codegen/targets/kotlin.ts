import { mkdir, writeFile } from 'node:fs/promises'
import { dirname } from 'node:path'
import { TranslationContract } from '../contract.js'

interface KotlinEnumCase {
  rawValue: string
  enumName: string
}

/**
 * Options for Kotlin target generation.
 */
export interface GenerateKotlinTargetOptions {
  /**
   * Canonical translation contract used as source of truth.
   */
  contract: TranslationContract<string>
  /**
   * Absolute output path for generated Kotlin file.
   */
  outputPath: string
}

/**
 * Result for generated Kotlin target artifacts.
 */
export interface GenerateKotlinTargetResult {
  /**
   * Absolute output path for generated Kotlin file.
   */
  outputPath: string
}

const toKotlinEnumName = (value: string): string => {
  const normalized = value
    .trim()
    .replace(/[^A-Za-z0-9]+/g, '_')
    .replace(/^_+|_+$/g, '')
    .toUpperCase()

  if (normalized.length === 0) {
    return 'VALUE'
  }

  if (/^[0-9]/.test(normalized)) {
    return `_${normalized}`
  }

  return normalized
}

const toUniqueKotlinCases = (values: ReadonlyArray<string>): ReadonlyArray<KotlinEnumCase> => {
  const usedNames = new Map<string, number>()

  return values.map((rawValue) => {
    const baseName = toKotlinEnumName(rawValue)
    const count = usedNames.get(baseName) ?? 0
    usedNames.set(baseName, count + 1)

    return {
      rawValue,
      enumName: count === 0 ? baseName : `${baseName}_${count + 1}`,
    }
  })
}

const toKotlinStringLiteral = (value: string): string =>
  `"${value.replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`

const toLocaleMapSource = (entries: ReadonlyArray<{ key: string; value: string }>): string => {
  if (entries.length === 0) {
    return 'emptyMap()'
  }

  const lines = entries.map(
    (entry) => `    TranslationLanguage.${entry.key} to ${toKotlinStringLiteral(entry.value)}`
  )

  return `mapOf(
${lines.join(',\n')}
  )`
}

const toKotlinSource = (contract: TranslationContract<string>): string => {
  const languageCases = toUniqueKotlinCases(contract.languages)
  const keyCases = toUniqueKotlinCases(contract.entries.map((entry) => entry.key))
  const categoryCases = toUniqueKotlinCases(
    Array.from(new Set(contract.entries.map((entry) => entry.category)))
  )
  const languageByRawValue = new Map(languageCases.map((entry) => [entry.rawValue, entry.enumName]))

  const sourceLanguage = languageByRawValue.get(contract.sourceLanguage)
  if (!sourceLanguage) {
    throw new Error(
      `Kotlin generation failed: source language "${contract.sourceLanguage}" is not declared in contract languages.`
    )
  }

  const localeEntries = Object.entries(contract.localeByLanguage)
    .map(([language, locale]) => {
      const enumName = languageByRawValue.get(language)
      if (!enumName) {
        return null
      }
      return {
        key: enumName,
        value: locale,
      }
    })
    .filter((entry): entry is { key: string; value: string } => entry !== null)

  const languageEnums = languageCases
    .map((entry) => `  ${entry.enumName}(${toKotlinStringLiteral(entry.rawValue)})`)
    .join(',\n')
  const keyEnums = keyCases
    .map((entry) => `  ${entry.enumName}(${toKotlinStringLiteral(entry.rawValue)})`)
    .join(',\n')
  const categoryEnums = categoryCases
    .map((entry) => `  ${entry.enumName}(${toKotlinStringLiteral(entry.rawValue)})`)
    .join(',\n')

  return `// This file is generated by typekit-i18n. Do not edit manually.
import java.io.File
import java.util.Base64
import java.util.Date

enum class TranslationLanguage(val code: String) {
${languageEnums};

  companion object {
    @JvmStatic
    fun fromCode(code: String): TranslationLanguage? = values().firstOrNull { it.code == code }
  }
}

enum class TranslationKey(val rawValue: String) {
${keyEnums};

  companion object {
    @JvmStatic
    fun fromRawValue(rawValue: String): TranslationKey? =
      values().firstOrNull { it.rawValue == rawValue }
  }
}

enum class TranslationCategory(val rawValue: String) {
${categoryEnums};

  companion object {
    @JvmStatic
    fun fromRawValue(rawValue: String): TranslationCategory? =
      values().firstOrNull { it.rawValue == rawValue }
  }
}

sealed class TranslationPlaceholderValue {
  data class Text(val value: String) : TranslationPlaceholderValue()
  data class Number(val value: Double) : TranslationPlaceholderValue()
  data class Bool(val value: Boolean) : TranslationPlaceholderValue()
  data class Timestamp(val value: Date) : TranslationPlaceholderValue()

  fun bridgeValue(): Any =
    when (this) {
      is Text -> value
      is Number -> value
      is Bool -> value
      is Timestamp -> value.time
    }
}

data class TranslationPlaceholder(
  val key: String,
  val value: TranslationPlaceholderValue
)

class TypekitKotlinBridgeException(message: String) : RuntimeException(message)

interface TranslationRuntimeBridge {
  @Throws(Exception::class)
  fun translate(
    key: String,
    language: String,
    placeholders: List<TranslationPlaceholder>
  ): String
}

class LambdaTranslationRuntimeBridge(
  private val handler: (String, String, List<TranslationPlaceholder>) -> String
) : TranslationRuntimeBridge {
  @Throws(Exception::class)
  override fun translate(
    key: String,
    language: String,
    placeholders: List<TranslationPlaceholder>
  ): String = handler(key, language, placeholders)
}

class NodeTranslationRuntimeBridge @JvmOverloads constructor(
  private val runtimeBundlePath: String,
  private val functionName: String = "__typekitTranslate",
  private val nodeCommand: String = "node"
) : TranslationRuntimeBridge {
  @Throws(Exception::class)
  override fun translate(
    key: String,
    language: String,
    placeholders: List<TranslationPlaceholder>
  ): String {
    val runtimeBundleFile = File(runtimeBundlePath)
    if (!runtimeBundleFile.isFile) {
      throw TypekitKotlinBridgeException("Runtime bundle not found: $runtimeBundlePath")
    }

    val payload = toPayloadJson(key, language, placeholders)
    val process = ProcessBuilder(
      nodeCommand,
      "-e",
      NODE_BRIDGE_SCRIPT,
      runtimeBundleFile.path,
      functionName
    ).start()

    process.outputStream.use { stream ->
      stream.write(payload.toByteArray(Charsets.UTF_8))
    }

    val stdout = process.inputStream.bufferedReader(Charsets.UTF_8).use { reader ->
      reader.readText()
    }
    val stderr = process.errorStream.bufferedReader(Charsets.UTF_8).use { reader ->
      reader.readText()
    }
    val exitCode = process.waitFor()

    if (exitCode != 0) {
      val message = stderr.ifBlank { stdout }.ifBlank { "Unknown JavaScript bridge failure." }
      throw TypekitKotlinBridgeException("JavaScript bridge execution failed: $message")
    }

    return decodeOutput(stdout)
  }

  private fun toPayloadJson(
    key: String,
    language: String,
    placeholders: List<TranslationPlaceholder>
  ): String {
    val placeholderEntries = placeholders.joinToString(",") { placeholder ->
      toPlaceholderEntryJson(placeholder)
    }

    return "{\\"keyBase64\\":\\"" +
      encodeBase64(key) +
      "\\",\\"languageBase64\\":\\"" +
      encodeBase64(language) +
      "\\",\\"placeholders\\":[" +
      placeholderEntries +
      "]}"
  }

  private fun toPlaceholderEntryJson(placeholder: TranslationPlaceholder): String {
    val keyBase64 = encodeBase64(placeholder.key)
    return when (val value = placeholder.value) {
      is TranslationPlaceholderValue.Text ->
        "{\\"keyBase64\\":\\"" +
          keyBase64 +
          "\\",\\"kind\\":\\"text\\",\\"textBase64\\":\\"" +
          encodeBase64(value.value) +
          "\\"}"
      is TranslationPlaceholderValue.Number ->
        "{\\"keyBase64\\":\\"" +
          keyBase64 +
          "\\",\\"kind\\":\\"number\\",\\"number\\":" +
          numberToJson(value.value) +
          "}"
      is TranslationPlaceholderValue.Bool ->
        "{\\"keyBase64\\":\\"" +
          keyBase64 +
          "\\",\\"kind\\":\\"bool\\",\\"bool\\":" +
          value.value +
          "}"
      is TranslationPlaceholderValue.Timestamp ->
        "{\\"keyBase64\\":\\"" +
          keyBase64 +
          "\\",\\"kind\\":\\"timestamp\\",\\"timestampMs\\":" +
          value.value.time +
          "}"
    }
  }

  private fun numberToJson(value: Double): String {
    if (!value.isFinite()) {
      throw TypekitKotlinBridgeException("Unsupported non-finite placeholder number.")
    }
    return value.toString()
  }

  private fun encodeBase64(value: String): String =
    Base64.getEncoder().encodeToString(value.toByteArray(Charsets.UTF_8))

  private fun decodeOutput(output: String): String {
    if (output.startsWith("B64:")) {
      val payload = output.substring(4)
      return String(Base64.getDecoder().decode(payload), Charsets.UTF_8)
    }
    return output
  }

  companion object {
    private val NODE_BRIDGE_SCRIPT = """
const fs = require('node:fs')
const vm = require('node:vm')

const runtimeBundlePath = process.argv[1]
const functionName = process.argv[2]
const payloadSource = fs.readFileSync(0, 'utf8')
const decodeBase64 = (value) => Buffer.from(value, 'base64').toString('utf8')

const toBridgePayload = (payload = {}) => {
  const key = typeof payload.keyBase64 === 'string' ? decodeBase64(payload.keyBase64) : ''
  const language =
    typeof payload.languageBase64 === 'string' ? decodeBase64(payload.languageBase64) : ''
  const placeholders = {}
  const entries = Array.isArray(payload.placeholders) ? payload.placeholders : []

  for (const entry of entries) {
    if (!entry || typeof entry !== 'object') {
      continue
    }
    const keyBase64 = typeof entry.keyBase64 === 'string' ? entry.keyBase64 : ''
    const placeholderKey = decodeBase64(keyBase64)
    const kind = typeof entry.kind === 'string' ? entry.kind : ''

    if (kind === 'text') {
      placeholders[placeholderKey] =
        typeof entry.textBase64 === 'string' ? decodeBase64(entry.textBase64) : ''
      continue
    }
    if (kind === 'number') {
      placeholders[placeholderKey] = typeof entry.number === 'number' ? entry.number : 0
      continue
    }
    if (kind === 'bool') {
      placeholders[placeholderKey] = typeof entry.bool === 'boolean' ? entry.bool : false
      continue
    }
    if (kind === 'timestamp') {
      placeholders[placeholderKey] =
        typeof entry.timestampMs === 'number' ? entry.timestampMs : 0
    }
  }

  return {
    key,
    language,
    placeholders,
  }
}

try {
  const context = vm.createContext({ console })
  context.globalThis = context
  const runtimeBundleSource = fs.readFileSync(runtimeBundlePath, 'utf8')
  vm.runInContext(runtimeBundleSource, context, { filename: runtimeBundlePath })
  const bridgeFunction = context[functionName]
  if (typeof bridgeFunction !== 'function') {
    throw new Error('Bridge function "' + functionName + '" was not installed.')
  }

  const payload = JSON.parse(payloadSource)
  const bridgePayload = toBridgePayload(payload)
  const result = bridgeFunction(bridgePayload)

  if (typeof result === 'string') {
    process.stdout.write('B64:' + Buffer.from(result, 'utf8').toString('base64'))
    process.exit(0)
  }

  if (result && typeof result === 'object') {
    if (typeof result.value === 'string') {
      process.stdout.write('B64:' + Buffer.from(result.value, 'utf8').toString('base64'))
      process.exit(0)
    }
    if (typeof result.missingReason === 'string') {
      throw new Error('Missing translation: ' + result.missingReason)
    }
  }

  throw new Error('Runtime bridge returned an unsupported result type.')
} catch (error) {
  const message = error && typeof error.message === 'string' ? error.message : String(error)
  process.stderr.write(message)
  process.exit(1)
}
""".trimIndent()
  }
}

object TranslationContractInfo {
  @JvmField
  val sourceLanguage: TranslationLanguage = TranslationLanguage.${sourceLanguage}

  @JvmField
  val languages: List<TranslationLanguage> = TranslationLanguage.values().toList()

  @JvmField
  val categories: List<TranslationCategory> = TranslationCategory.values().toList()

  @JvmField
  val localeByLanguage: Map<TranslationLanguage, String> = ${toLocaleMapSource(localeEntries)}
}

class TypekitTranslator @JvmOverloads constructor(
  private val bridge: TranslationRuntimeBridge,
  val defaultLanguage: TranslationLanguage = TranslationContractInfo.sourceLanguage,
  language: TranslationLanguage = defaultLanguage
) {
  private var languageState: TranslationLanguage = language

  fun setLanguage(language: TranslationLanguage): TypekitTranslator {
    languageState = language
    return this
  }

  fun getLanguage(): TranslationLanguage = languageState

  @Throws(Exception::class)
  fun translate(
    key: TranslationKey,
    placeholders: List<TranslationPlaceholder>
  ): String = translate(
    key = key,
    language = languageState,
    placeholders = placeholders
  )

  @JvmOverloads
  @Throws(Exception::class)
  fun translate(
    key: TranslationKey,
    language: TranslationLanguage = languageState,
    placeholders: List<TranslationPlaceholder> = emptyList()
  ): String {
    return bridge.translate(
      key = key.rawValue,
      language = language.code,
      placeholders = placeholders
    )
  }

  @Throws(Exception::class)
  fun translate(
    category: TranslationCategory,
    key: TranslationKey,
    placeholders: List<TranslationPlaceholder>
  ): String = translate(
    category = category,
    key = key,
    language = languageState,
    placeholders = placeholders
  )

  @JvmOverloads
  @Throws(Exception::class)
  fun translate(
    category: TranslationCategory,
    key: TranslationKey,
    language: TranslationLanguage = languageState,
    placeholders: List<TranslationPlaceholder> = emptyList()
  ): String {
    category.rawValue
    return translate(key, language, placeholders)
  }
}

object TypekitJavaInterop {
  @JvmStatic
  fun language(code: String): TranslationLanguage? = TranslationLanguage.fromCode(code)

  @JvmStatic
  fun key(rawValue: String): TranslationKey? = TranslationKey.fromRawValue(rawValue)

  @JvmStatic
  fun category(rawValue: String): TranslationCategory? = TranslationCategory.fromRawValue(rawValue)

  @JvmStatic
  @JvmOverloads
  fun createTranslator(
    bridge: TranslationRuntimeBridge,
    defaultLanguage: TranslationLanguage = TranslationContractInfo.sourceLanguage
  ): TypekitTranslator = TypekitTranslator(bridge = bridge, defaultLanguage = defaultLanguage)

  @JvmStatic
  @Throws(Exception::class)
  fun translate(
    translator: TypekitTranslator,
    key: TranslationKey,
    language: TranslationLanguage
  ): String = translator.translate(key, language)

  @JvmStatic
  @Throws(Exception::class)
  fun translate(
    translator: TypekitTranslator,
    key: String,
    languageCode: String
  ): String {
    val resolvedKey = TranslationKey.fromRawValue(key)
      ?: throw TypekitKotlinBridgeException("Unknown translation key: $key")
    val resolvedLanguage = TranslationLanguage.fromCode(languageCode)
      ?: throw TypekitKotlinBridgeException("Unknown translation language: $languageCode")
    return translator.translate(resolvedKey, resolvedLanguage)
  }
}
`
}

/**
 * Generates Kotlin artifacts from canonical translation contract.
 *
 * @param options Kotlin target generation options.
 * @returns Generated Kotlin output path.
 */
export const generateKotlinTarget = async (
  options: GenerateKotlinTargetOptions
): Promise<GenerateKotlinTargetResult> => {
  await mkdir(dirname(options.outputPath), { recursive: true })
  await writeFile(options.outputPath, toKotlinSource(options.contract), 'utf-8')

  return {
    outputPath: options.outputPath,
  }
}
