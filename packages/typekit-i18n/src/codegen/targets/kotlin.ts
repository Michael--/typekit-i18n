import { mkdir, writeFile } from 'node:fs/promises'
import { dirname } from 'node:path'
import { TranslationContract } from '../contract.js'

interface KotlinEnumCase {
  rawValue: string
  enumName: string
}

/**
 * Options for Kotlin target generation.
 */
export interface GenerateKotlinTargetOptions {
  /**
   * Canonical translation contract used as source of truth.
   */
  contract: TranslationContract<string>
  /**
   * Absolute output path for generated Kotlin file.
   */
  outputPath: string
}

/**
 * Result for generated Kotlin target artifacts.
 */
export interface GenerateKotlinTargetResult {
  /**
   * Absolute output path for generated Kotlin file.
   */
  outputPath: string
}

const toKotlinEnumName = (value: string): string => {
  const normalized = value
    .trim()
    .replace(/[^A-Za-z0-9]+/g, '_')
    .replace(/^_+|_+$/g, '')
    .toUpperCase()

  if (normalized.length === 0) {
    return 'VALUE'
  }

  if (/^[0-9]/.test(normalized)) {
    return `_${normalized}`
  }

  return normalized
}

const toUniqueKotlinCases = (values: ReadonlyArray<string>): ReadonlyArray<KotlinEnumCase> => {
  const usedNames = new Map<string, number>()

  return values.map((rawValue) => {
    const baseName = toKotlinEnumName(rawValue)
    const count = usedNames.get(baseName) ?? 0
    usedNames.set(baseName, count + 1)

    return {
      rawValue,
      enumName: count === 0 ? baseName : `${baseName}_${count + 1}`,
    }
  })
}

const toKotlinStringLiteral = (value: string): string =>
  `"${value.replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`

const toLocaleMapSource = (entries: ReadonlyArray<{ key: string; value: string }>): string => {
  if (entries.length === 0) {
    return 'emptyMap()'
  }

  const lines = entries.map(
    (entry) => `    TranslationLanguage.${entry.key} to ${toKotlinStringLiteral(entry.value)}`
  )

  return `mapOf(
${lines.join(',\n')}
  )`
}

const toKotlinSource = (contract: TranslationContract<string>): string => {
  const languageCases = toUniqueKotlinCases(contract.languages)
  const keyCases = toUniqueKotlinCases(contract.entries.map((entry) => entry.key))
  const categoryCases = toUniqueKotlinCases(
    Array.from(new Set(contract.entries.map((entry) => entry.category)))
  )
  const languageByRawValue = new Map(languageCases.map((entry) => [entry.rawValue, entry.enumName]))

  const sourceLanguage = languageByRawValue.get(contract.sourceLanguage)
  if (!sourceLanguage) {
    throw new Error(
      `Kotlin generation failed: source language "${contract.sourceLanguage}" is not declared in contract languages.`
    )
  }

  const localeEntries = Object.entries(contract.localeByLanguage)
    .map(([language, locale]) => {
      const enumName = languageByRawValue.get(language)
      if (!enumName) {
        return null
      }
      return {
        key: enumName,
        value: locale,
      }
    })
    .filter((entry): entry is { key: string; value: string } => entry !== null)

  const languageEnums = languageCases
    .map((entry) => `  ${entry.enumName}(${toKotlinStringLiteral(entry.rawValue)})`)
    .join(',\n')
  const keyEnums = keyCases
    .map((entry) => `  ${entry.enumName}(${toKotlinStringLiteral(entry.rawValue)})`)
    .join(',\n')
  const categoryEnums = categoryCases
    .map((entry) => `  ${entry.enumName}(${toKotlinStringLiteral(entry.rawValue)})`)
    .join(',\n')

  return `// This file is generated by typekit-i18n. Do not edit manually.
import java.util.Date

enum class TranslationLanguage(val code: String) {
${languageEnums};

  companion object {
    @JvmStatic
    fun fromCode(code: String): TranslationLanguage? = values().firstOrNull { it.code == code }
  }
}

enum class TranslationKey(val rawValue: String) {
${keyEnums};

  companion object {
    @JvmStatic
    fun fromRawValue(rawValue: String): TranslationKey? =
      values().firstOrNull { it.rawValue == rawValue }
  }
}

enum class TranslationCategory(val rawValue: String) {
${categoryEnums};

  companion object {
    @JvmStatic
    fun fromRawValue(rawValue: String): TranslationCategory? =
      values().firstOrNull { it.rawValue == rawValue }
  }
}

sealed class TranslationPlaceholderValue {
  data class Text(val value: String) : TranslationPlaceholderValue()
  data class Number(val value: Double) : TranslationPlaceholderValue()
  data class Bool(val value: Boolean) : TranslationPlaceholderValue()
  data class Timestamp(val value: Date) : TranslationPlaceholderValue()

  fun bridgeValue(): Any =
    when (this) {
      is Text -> value
      is Number -> value
      is Bool -> value
      is Timestamp -> value.time
    }
}

data class TranslationPlaceholder(
  val key: String,
  val value: TranslationPlaceholderValue
)

class TypekitKotlinBridgeException(message: String) : RuntimeException(message)

interface TranslationRuntimeBridge {
  @Throws(Exception::class)
  fun translate(
    key: String,
    language: String,
    placeholders: List<TranslationPlaceholder>
  ): String
}

class LambdaTranslationRuntimeBridge(
  private val handler: (String, String, List<TranslationPlaceholder>) -> String
) : TranslationRuntimeBridge {
  @Throws(Exception::class)
  override fun translate(
    key: String,
    language: String,
    placeholders: List<TranslationPlaceholder>
  ): String = handler(key, language, placeholders)
}

object TranslationContractInfo {
  @JvmField
  val sourceLanguage: TranslationLanguage = TranslationLanguage.${sourceLanguage}

  @JvmField
  val languages: List<TranslationLanguage> = TranslationLanguage.values().toList()

  @JvmField
  val categories: List<TranslationCategory> = TranslationCategory.values().toList()

  @JvmField
  val localeByLanguage: Map<TranslationLanguage, String> = ${toLocaleMapSource(localeEntries)}
}

class TypekitTranslator @JvmOverloads constructor(
  private val bridge: TranslationRuntimeBridge,
  val defaultLanguage: TranslationLanguage = TranslationContractInfo.sourceLanguage,
  language: TranslationLanguage = defaultLanguage
) {
  private var languageState: TranslationLanguage = language

  fun setLanguage(language: TranslationLanguage): TypekitTranslator {
    languageState = language
    return this
  }

  fun getLanguage(): TranslationLanguage = languageState

  @JvmOverloads
  @Throws(Exception::class)
  fun translate(
    key: TranslationKey,
    language: TranslationLanguage = languageState,
    placeholders: List<TranslationPlaceholder> = emptyList()
  ): String {
    return bridge.translate(
      key = key.rawValue,
      language = language.code,
      placeholders = placeholders
    )
  }

  @JvmOverloads
  @Throws(Exception::class)
  fun translate(
    category: TranslationCategory,
    key: TranslationKey,
    language: TranslationLanguage = languageState,
    placeholders: List<TranslationPlaceholder> = emptyList()
  ): String {
    category.rawValue
    return translate(key, language, placeholders)
  }
}

object TypekitJavaInterop {
  @JvmStatic
  fun language(code: String): TranslationLanguage? = TranslationLanguage.fromCode(code)

  @JvmStatic
  fun key(rawValue: String): TranslationKey? = TranslationKey.fromRawValue(rawValue)

  @JvmStatic
  fun category(rawValue: String): TranslationCategory? = TranslationCategory.fromRawValue(rawValue)

  @JvmStatic
  fun createTranslator(
    bridge: TranslationRuntimeBridge,
    defaultLanguage: TranslationLanguage = TranslationContractInfo.sourceLanguage
  ): TypekitTranslator = TypekitTranslator(bridge = bridge, defaultLanguage = defaultLanguage)

  @JvmStatic
  @Throws(Exception::class)
  fun translate(
    translator: TypekitTranslator,
    key: TranslationKey,
    language: TranslationLanguage
  ): String = translator.translate(key, language)

  @JvmStatic
  @Throws(Exception::class)
  fun translate(
    translator: TypekitTranslator,
    key: String,
    languageCode: String
  ): String {
    val resolvedKey = TranslationKey.fromRawValue(key)
      ?: throw TypekitKotlinBridgeException("Unknown translation key: $key")
    val resolvedLanguage = TranslationLanguage.fromCode(languageCode)
      ?: throw TypekitKotlinBridgeException("Unknown translation language: $languageCode")
    return translator.translate(resolvedKey, resolvedLanguage)
  }
}
`
}

/**
 * Generates Kotlin artifacts from canonical translation contract.
 *
 * @param options Kotlin target generation options.
 * @returns Generated Kotlin output path.
 */
export const generateKotlinTarget = async (
  options: GenerateKotlinTargetOptions
): Promise<GenerateKotlinTargetResult> => {
  await mkdir(dirname(options.outputPath), { recursive: true })
  await writeFile(options.outputPath, toKotlinSource(options.contract), 'utf-8')

  return {
    outputPath: options.outputPath,
  }
}
