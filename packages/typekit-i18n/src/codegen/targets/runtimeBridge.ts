import { existsSync } from 'node:fs'
import { mkdir, writeFile } from 'node:fs/promises'
import { dirname, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { build } from 'esbuild'
import { TranslationContract } from '../contract.js'
import { RuntimeBridgeMode } from '../types.js'

const DEFAULT_RUNTIME_BRIDGE_FUNCTION_NAME = '__typekitTranslate'
const RUNTIME_ICU_IMPORT = '@number10/typekit-i18n/runtime/icu'
const RUNTIME_BASIC_IMPORT = '@number10/typekit-i18n/runtime/basic'
const MODULE_DIRECTORY_PATH = dirname(fileURLToPath(import.meta.url))

const resolvePackageRootPath = (): string => {
  let cursor = MODULE_DIRECTORY_PATH
  for (let index = 0; index < 10; index += 1) {
    const hasSourceRuntime = existsSync(resolve(cursor, 'src/runtime/icu.ts'))
    const hasDistRuntime = existsSync(resolve(cursor, 'dist/runtime-icu.js'))
    if (hasSourceRuntime || hasDistRuntime) {
      return cursor
    }

    const next = dirname(cursor)
    if (next === cursor) {
      break
    }
    cursor = next
  }

  throw new Error('Unable to resolve package root path for runtime bridge bundling.')
}

const resolveRuntimeImportAlias = (runtimeImportPath: string): string => {
  const packageRootPath = resolvePackageRootPath()

  if (runtimeImportPath === RUNTIME_ICU_IMPORT) {
    const sourceCandidate = resolve(packageRootPath, 'src/runtime/icu.ts')
    if (existsSync(sourceCandidate)) {
      return sourceCandidate
    }
    const distCandidate = resolve(packageRootPath, 'dist/runtime-icu.js')
    if (existsSync(distCandidate)) {
      return distCandidate
    }
  }
  if (runtimeImportPath === RUNTIME_BASIC_IMPORT) {
    const sourceCandidate = resolve(packageRootPath, 'src/runtime/basic.ts')
    if (existsSync(sourceCandidate)) {
      return sourceCandidate
    }
    const distCandidate = resolve(packageRootPath, 'dist/runtime-basic.js')
    if (existsSync(distCandidate)) {
      return distCandidate
    }
  }

  throw new Error(
    `Unable to resolve runtime import "${runtimeImportPath}" for runtime bridge bundling.`
  )
}

/**
 * Options for runtime bridge target generation.
 */
export interface GenerateRuntimeBridgeTargetOptions {
  /**
   * Canonical translation contract used as source of truth.
   */
  contract: TranslationContract<string>
  /**
   * Absolute output path for generated runtime bridge module.
   */
  outputPath: string
  /**
   * Runtime bridge generation mode.
   * Defaults to `icu`.
   */
  mode?: RuntimeBridgeMode
  /**
   * Global function name installed on `globalThis`.
   * Defaults to `__typekitTranslate`.
   */
  functionName?: string
}

/**
 * Result for generated runtime bridge artifact.
 */
export interface GenerateRuntimeBridgeTargetResult {
  /**
   * Absolute output path for generated runtime bridge module.
   */
  outputPath: string
}

/**
 * Options for bundling runtime bridge module into a direct-eval script.
 */
export interface BundleRuntimeBridgeTargetOptions {
  /**
   * Absolute input path for generated runtime bridge module.
   */
  inputPath: string
  /**
   * Absolute output path for generated bundled runtime bridge script.
   */
  outputPath: string
}

/**
 * Result for generated bundled runtime bridge script.
 */
export interface BundleRuntimeBridgeTargetResult {
  /**
   * Absolute output path for generated bundled runtime bridge script.
   */
  outputPath: string
}

const toBridgeModuleSource = (
  contract: TranslationContract<string>,
  mode: RuntimeBridgeMode,
  functionName: string
): string => {
  const importSource =
    mode === 'icu'
      ? `import { createIcuTranslator } from '${RUNTIME_ICU_IMPORT}'`
      : `import { createTranslator } from '${RUNTIME_BASIC_IMPORT}'`
  const createTranslatorCall =
    mode === 'icu'
      ? `const typekitTranslator = createIcuTranslator(translationTable, {
  defaultLanguage,
  localeByLanguage,
})`
      : `const typekitTranslator = createTranslator(translationTable, {
  defaultLanguage,
})`

  const tableSource = JSON.stringify(
    Object.fromEntries(
      contract.entries.map((entry) => [
        entry.key,
        {
          category: entry.category,
          description: entry.description,
          ...entry.values,
        },
      ])
    ),
    null,
    2
  )
  const localeByLanguageSource = JSON.stringify(contract.localeByLanguage, null, 2)

  return `// This file is generated by typekit-i18n. Do not edit manually.
${importSource}

const defaultLanguage = ${JSON.stringify(contract.sourceLanguage)}
const localeByLanguage = ${localeByLanguageSource}
const translationTable = ${tableSource}

${createTranslatorCall}

const toPlaceholderData = (placeholders) => {
  if (!placeholders || typeof placeholders !== 'object') {
    return []
  }
  return Object.entries(placeholders).map(([key, value]) => ({ key, value }))
}

export const installTypekitRuntimeBridge = (
  globalObject = globalThis,
  bridgeFunctionName = ${JSON.stringify(functionName)}
) => {
  const translate = (payload = {}) => {
    const key = typeof payload.key === 'string' ? payload.key : ''
    const language =
      typeof payload.language === 'string' && payload.language.length > 0
        ? payload.language
        : defaultLanguage
    return typekitTranslator(key, language, {
      data: toPlaceholderData(payload.placeholders),
    })
  }
  globalObject[bridgeFunctionName] = translate
  return translate
}

export { defaultLanguage, localeByLanguage, translationTable, typekitTranslator }

installTypekitRuntimeBridge(globalThis, ${JSON.stringify(functionName)})
`
}

/**
 * Generates shared JS runtime bridge artifact from canonical translation contract.
 *
 * @param options Runtime bridge target generation options.
 * @returns Generated runtime bridge output path.
 */
export const generateRuntimeBridgeTarget = async (
  options: GenerateRuntimeBridgeTargetOptions
): Promise<GenerateRuntimeBridgeTargetResult> => {
  const mode = options.mode ?? 'icu'
  const functionName = options.functionName ?? DEFAULT_RUNTIME_BRIDGE_FUNCTION_NAME

  await mkdir(dirname(options.outputPath), { recursive: true })
  await writeFile(
    options.outputPath,
    toBridgeModuleSource(options.contract, mode, functionName),
    'utf-8'
  )

  return {
    outputPath: options.outputPath,
  }
}

/**
 * Bundles generated runtime bridge module into an IIFE script.
 *
 * @param options Runtime bridge bundling options.
 * @returns Generated bundle output path.
 */
export const bundleRuntimeBridgeTarget = async (
  options: BundleRuntimeBridgeTargetOptions
): Promise<BundleRuntimeBridgeTargetResult> => {
  const packageRootPath = resolvePackageRootPath()
  const runtimeIcuImportAlias = resolveRuntimeImportAlias(RUNTIME_ICU_IMPORT)
  const runtimeBasicImportAlias = resolveRuntimeImportAlias(RUNTIME_BASIC_IMPORT)

  await mkdir(dirname(options.outputPath), { recursive: true })

  await build({
    entryPoints: [options.inputPath],
    outfile: options.outputPath,
    absWorkingDir: packageRootPath,
    bundle: true,
    alias: {
      [RUNTIME_ICU_IMPORT]: runtimeIcuImportAlias,
      [RUNTIME_BASIC_IMPORT]: runtimeBasicImportAlias,
    },
    format: 'iife',
    platform: 'browser',
    target: ['es2020'],
    sourcemap: false,
    minify: false,
    logLevel: 'silent',
  })

  return {
    outputPath: options.outputPath,
  }
}
