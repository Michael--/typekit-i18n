import { mkdir, writeFile } from 'node:fs/promises'
import { dirname } from 'node:path'
import { TranslationContract } from '../contract.js'
import { RuntimeBridgeMode } from '../types.js'

const DEFAULT_RUNTIME_BRIDGE_FUNCTION_NAME = '__typekitTranslate'

/**
 * Options for runtime bridge target generation.
 */
export interface GenerateRuntimeBridgeTargetOptions {
  /**
   * Canonical translation contract used as source of truth.
   */
  contract: TranslationContract<string>
  /**
   * Absolute output path for generated runtime bridge module.
   */
  outputPath: string
  /**
   * Runtime bridge generation mode.
   * Defaults to `icu`.
   */
  mode?: RuntimeBridgeMode
  /**
   * Global function name installed on `globalThis`.
   * Defaults to `__typekitTranslate`.
   */
  functionName?: string
}

/**
 * Result for generated runtime bridge artifact.
 */
export interface GenerateRuntimeBridgeTargetResult {
  /**
   * Absolute output path for generated runtime bridge module.
   */
  outputPath: string
}

const toBridgeModuleSource = (
  contract: TranslationContract<string>,
  mode: RuntimeBridgeMode,
  functionName: string
): string => {
  const importSource =
    mode === 'icu'
      ? "import { createIcuTranslator } from '@number10/typekit-i18n/runtime/icu'"
      : "import { createTranslator } from '@number10/typekit-i18n/runtime/basic'"
  const createTranslatorCall =
    mode === 'icu'
      ? `const typekitTranslator = createIcuTranslator(translationTable, {
  defaultLanguage,
  localeByLanguage,
})`
      : `const typekitTranslator = createTranslator(translationTable, {
  defaultLanguage,
})`

  const tableSource = JSON.stringify(
    Object.fromEntries(
      contract.entries.map((entry) => [
        entry.key,
        {
          category: entry.category,
          description: entry.description,
          ...entry.values,
        },
      ])
    ),
    null,
    2
  )
  const localeByLanguageSource = JSON.stringify(contract.localeByLanguage, null, 2)

  return `// This file is generated by typekit-i18n. Do not edit manually.
${importSource}

const defaultLanguage = ${JSON.stringify(contract.sourceLanguage)}
const localeByLanguage = ${localeByLanguageSource}
const translationTable = ${tableSource}

${createTranslatorCall}

const toPlaceholderData = (placeholders) => {
  if (!placeholders || typeof placeholders !== 'object') {
    return []
  }
  return Object.entries(placeholders).map(([key, value]) => ({ key, value }))
}

export const installTypekitRuntimeBridge = (
  globalObject = globalThis,
  bridgeFunctionName = ${JSON.stringify(functionName)}
) => {
  const translate = (payload = {}) => {
    const key = typeof payload.key === 'string' ? payload.key : ''
    const language =
      typeof payload.language === 'string' && payload.language.length > 0
        ? payload.language
        : defaultLanguage
    return typekitTranslator(key, language, {
      data: toPlaceholderData(payload.placeholders),
    })
  }
  globalObject[bridgeFunctionName] = translate
  return translate
}

export { defaultLanguage, localeByLanguage, translationTable, typekitTranslator }

installTypekitRuntimeBridge(globalThis, ${JSON.stringify(functionName)})
`
}

/**
 * Generates shared JS runtime bridge artifact from canonical translation contract.
 *
 * @param options Runtime bridge target generation options.
 * @returns Generated runtime bridge output path.
 */
export const generateRuntimeBridgeTarget = async (
  options: GenerateRuntimeBridgeTargetOptions
): Promise<GenerateRuntimeBridgeTargetResult> => {
  const mode = options.mode ?? 'icu'
  const functionName = options.functionName ?? DEFAULT_RUNTIME_BRIDGE_FUNCTION_NAME

  await mkdir(dirname(options.outputPath), { recursive: true })
  await writeFile(
    options.outputPath,
    toBridgeModuleSource(options.contract, mode, functionName),
    'utf-8'
  )

  return {
    outputPath: options.outputPath,
  }
}
