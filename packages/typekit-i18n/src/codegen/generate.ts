import { glob } from 'glob'
import { dirname, extname, join, relative, resolve } from 'node:path'
import { mkdir, readFile, writeFile } from 'node:fs/promises'
import pc from 'picocolors'
import {
  createTranslationContract,
  toTranslationContractSource,
  TranslationContract,
} from './contract.js'
import { readCsvHeaders } from './csv.js'
import { toIrProjectFromCsvFile } from './ir/csv.js'
import { TranslationIrProject } from './ir/types.js'
import { toIrProjectFromYamlFile } from './ir/yaml.js'
import { generateKotlinTarget } from './targets/kotlin.js'
import { bundleRuntimeBridgeTarget, generateRuntimeBridgeTarget } from './targets/runtimeBridge.js'
import { generateSwiftTarget } from './targets/swift.js'
import {
  RuntimeBridgeMode,
  TranslationInputFormat,
  TranslationRecord,
  TypekitI18nConfig,
} from './types.js'
import { parse as parseYaml } from 'yaml'

const quote = (value: string): string => JSON.stringify(value)
const CSV_BASE_COLUMNS: ReadonlySet<string> = new Set(['key', 'description'])
const CSV_METADATA_COLUMNS: ReadonlySet<string> = new Set([
  'category',
  'status',
  'tags',
  'placeholders',
])
const DEFAULT_CATEGORY = 'default'
const SUPPORTED_CODEGEN_TARGETS = ['ts', 'swift', 'kotlin'] as const

/**
 * Supported generation target names.
 */
export type CodegenTarget = (typeof SUPPORTED_CODEGEN_TARGETS)[number]

/**
 * Options for multi-target generation.
 */
export interface GenerateTranslationsOptions {
  /**
   * Optional explicit target list.
   * Defaults to `["ts"]`.
   */
  targets?: ReadonlyArray<CodegenTarget>
}

/**
 * One target generation result.
 */
export interface GenerateTargetResult {
  /**
   * Target name.
   */
  target: CodegenTarget
  /**
   * Absolute output file paths generated by this target.
   */
  outputPaths: ReadonlyArray<string>
}

/**
 * Result from multi-target generation.
 */
export interface GenerateTranslationsResult {
  /**
   * Number of generated translation keys.
   */
  keyCount: number
  /**
   * Absolute output path for canonical contract artifact.
   */
  outputContractPath: string
  /**
   * Resolved target execution order.
   */
  targets: ReadonlyArray<CodegenTarget>
  /**
   * Per-target output file paths.
   */
  targetResults: ReadonlyArray<GenerateTargetResult>
  /**
   * Optional absolute output path for generated shared runtime bridge module.
   */
  runtimeBridgePath?: string
  /**
   * Optional absolute output path for generated bundled runtime bridge script.
   */
  runtimeBridgeBundlePath?: string
}

const toTypeUnion = (values: ReadonlyArray<string>): string =>
  values.length === 0 ? 'never' : values.map((value) => quote(value)).join(' | ')

const toCombinedErrorMessage = (errors: ReadonlyArray<string>): string => {
  if (errors.length === 1) {
    return errors[0]
  }
  const lines = errors.map((error) => `- ${error.split('\n').join('\n  ')}`)
  return `Generation failed with ${errors.length} error(s):\n${lines.join('\n')}`
}

const isCodegenTarget = (value: string): value is CodegenTarget =>
  (SUPPORTED_CODEGEN_TARGETS as ReadonlyArray<string>).includes(value)

/**
 * Resolves and validates generation target names.
 *
 * @param targets Optional requested targets from CLI or API.
 * @returns Normalized unique targets in declaration order.
 * @throws When at least one target is unknown.
 */
export const resolveCodegenTargets = (
  targets?: ReadonlyArray<string>
): ReadonlyArray<CodegenTarget> => {
  if (!targets || targets.length === 0) {
    return ['ts']
  }

  const uniqueTargets = Array.from(new Set(targets))
  const resolvedTargets = uniqueTargets.filter((target): target is CodegenTarget =>
    isCodegenTarget(target)
  )
  const invalidTargets = uniqueTargets.filter((target) => !isCodegenTarget(target))

  if (invalidTargets.length > 0) {
    throw new Error(
      `Unsupported generation target(s): ${invalidTargets.join(', ')}. Supported targets: ${SUPPORTED_CODEGEN_TARGETS.join(', ')}.`
    )
  }

  return resolvedTargets
}

const normalizeLanguageList = (languages: ReadonlyArray<string>): ReadonlyArray<string> =>
  Array.from(
    new Set(languages.map((language) => language.trim()).filter((language) => language.length > 0))
  )

const normalizeCategory = (category: string | undefined): string => {
  if (typeof category !== 'string') {
    return DEFAULT_CATEGORY
  }

  const normalized = category.trim()
  return normalized.length > 0 ? normalized : DEFAULT_CATEGORY
}

const isLikelyLanguageCode = (value: string): boolean =>
  /^[A-Za-z]{2}(?:-[A-Za-z0-9_]+)?$/.test(value)

const toLanguageDeclarationMismatchMessage = (
  scope: string,
  declaredLanguages: ReadonlyArray<string>,
  configuredLanguages: ReadonlyArray<string>
): string | null => {
  const missingConfigured = configuredLanguages.filter(
    (language) => !declaredLanguages.includes(language)
  )
  const unconfigured = declaredLanguages.filter(
    (language) => !configuredLanguages.includes(language)
  )

  if (missingConfigured.length === 0 && unconfigured.length === 0) {
    return null
  }

  const details: string[] = []
  if (missingConfigured.length > 0) {
    details.push(`missing configured language(s): ${missingConfigured.join(', ')}`)
  }
  if (unconfigured.length > 0) {
    details.push(`unconfigured language(s): ${unconfigured.join(', ')}`)
  }

  return `Language declaration mismatch in ${scope}: ${details.join('; ')}. Configured languages: ${configuredLanguages.join(', ')}. Declared languages: ${declaredLanguages.join(', ')}.`
}

const validateLanguageConfig = <TLanguage extends string>(
  config: TypekitI18nConfig<TLanguage>
): void => {
  if (config.languages.length === 0) {
    throw new Error('Invalid configuration: "languages" must include at least one language.')
  }

  if (new Set(config.languages).size !== config.languages.length) {
    throw new Error('Invalid configuration: "languages" must not contain duplicate entries.')
  }

  if (!config.languages.includes(config.defaultLanguage)) {
    throw new Error(
      `Invalid configuration: default language "${config.defaultLanguage}" is not part of "languages".`
    )
  }

  if (!config.localeByLanguage) {
    return
  }

  for (const [language, locale] of Object.entries(config.localeByLanguage)) {
    if (!config.languages.includes(language as TLanguage)) {
      throw new Error(
        `Invalid configuration: locale mapping language "${language}" is not part of "languages".`
      )
    }

    if (typeof locale !== 'string' || locale.trim().length === 0) {
      throw new Error(
        `Invalid configuration: locale mapping for "${language}" must be a non-empty string.`
      )
    }
  }
}

const normalizeCsvIrErrorMessage = (message: string): string =>
  message.replace(/source language/g, 'default language')

const validateCsvLanguageDeclaration = async <TLanguage extends string>(
  filePath: string,
  config: TypekitI18nConfig<TLanguage>
): Promise<void> => {
  const headers = await readCsvHeaders(filePath)
  const declaredLanguages = normalizeLanguageList(
    headers.filter((header) => {
      if (CSV_BASE_COLUMNS.has(header) || CSV_METADATA_COLUMNS.has(header)) {
        return false
      }
      return config.languages.includes(header as TLanguage) || isLikelyLanguageCode(header)
    })
  )

  const mismatchMessage = toLanguageDeclarationMismatchMessage(
    `${filePath} header`,
    declaredLanguages,
    config.languages
  )
  if (mismatchMessage) {
    throw new Error(mismatchMessage)
  }
}

const readYamlDeclaredLanguages = async (
  filePath: string
): Promise<ReadonlyArray<string> | null> => {
  try {
    const content = await readFile(filePath, 'utf-8')
    const parsed = parseYaml(content) as unknown
    if (typeof parsed !== 'object' || parsed === null || Array.isArray(parsed)) {
      return null
    }

    const root = parsed as Record<string, unknown>
    const rawLanguages = root.languages
    if (!Array.isArray(rawLanguages)) {
      return null
    }

    const languages = rawLanguages.filter(
      (language): language is string => typeof language === 'string'
    )
    if (languages.length === 0) {
      return null
    }

    return normalizeLanguageList(languages)
  } catch {
    return null
  }
}

const validateYamlLanguageDeclaration = async <TLanguage extends string>(
  filePath: string,
  config: TypekitI18nConfig<TLanguage>
): Promise<void> => {
  const declaredLanguages = await readYamlDeclaredLanguages(filePath)
  if (!declaredLanguages) {
    return
  }

  const mismatchMessage = toLanguageDeclarationMismatchMessage(
    `${filePath} at "root.languages"`,
    declaredLanguages,
    config.languages
  )
  if (mismatchMessage) {
    throw new Error(mismatchMessage)
  }
}

const validateYamlProjectLanguageConfig = <TLanguage extends string>(
  project: TranslationIrProject<string>,
  config: TypekitI18nConfig<TLanguage>,
  filePath: string
): void => {
  if (project.sourceLanguage !== config.defaultLanguage) {
    throw new Error(
      `Source language mismatch in ${filePath}: config default language "${config.defaultLanguage}" does not match YAML source language "${project.sourceLanguage}".`
    )
  }

  const missingLanguages = config.languages.filter(
    (language) => !project.languages.includes(language)
  )
  if (missingLanguages.length > 0) {
    throw new Error(
      `YAML file ${filePath} is missing configured language(s): ${missingLanguages.join(', ')}.`
    )
  }

  const extraLanguages = project.languages.filter(
    (language) => !config.languages.includes(language as TLanguage)
  )
  if (extraLanguages.length > 0) {
    throw new Error(
      `YAML file ${filePath} contains unconfigured language(s): ${extraLanguages.join(', ')}.`
    )
  }
}

const inferInputFormatFromPath = (filePath: string): TranslationInputFormat => {
  const extension = extname(filePath).toLowerCase()
  if (extension === '.yaml' || extension === '.yml') {
    return 'yaml'
  }
  return 'csv'
}

const loadProjectFromFile = async <TLanguage extends string>(
  filePath: string,
  format: TranslationInputFormat,
  config: TypekitI18nConfig<TLanguage>
): Promise<TranslationIrProject<string>> => {
  if (format === 'csv') {
    await validateCsvLanguageDeclaration(filePath, config)
    return toIrProjectFromCsvFile(filePath, {
      languages: config.languages,
      sourceLanguage: config.defaultLanguage,
    }).catch((error: unknown) => {
      const message = error instanceof Error ? error.message : String(error)
      throw new Error(normalizeCsvIrErrorMessage(message))
    })
  }

  await validateYamlLanguageDeclaration(filePath, config)
  const project = await toIrProjectFromYamlFile(filePath)
  validateYamlProjectLanguageConfig(project, config, filePath)
  return project
}

const toEntryLocation = (
  format: TranslationInputFormat,
  filePath: string,
  entryIndex: number
): string =>
  format === 'csv'
    ? `${filePath} at row ${entryIndex + 2}`
    : `${filePath} at entry ${entryIndex + 1}`

const toHeaderComment = (files: ReadonlyArray<string>): string => {
  const lines = files.map((file, index) => `[${index + 1}/${files.length}] "${file}"`)
  return `/*
   This file is generated.
   Source files:
   ${lines.join('\n   ')}
*/
// cspell:disable
`
}

const toKeysModuleSource = <TLanguage extends string>(
  files: ReadonlyArray<string>,
  records: ReadonlyArray<TranslationRecord<TLanguage>>,
  languages: ReadonlyArray<TLanguage>
): string => {
  const keyUnion = toTypeUnion(records.map((record) => record.key))
  const languageTuple = `[${languages.map((language) => quote(language)).join(', ')}]`
  const categoryMap = new Map<string, string[]>()

  records.forEach((record) => {
    const category = normalizeCategory(record.category)
    const keys = categoryMap.get(category) ?? []
    keys.push(record.key)
    categoryMap.set(category, keys)
  })

  const categories = Array.from(categoryMap.keys()).sort((left, right) => {
    if (left === DEFAULT_CATEGORY) {
      return -1
    }
    if (right === DEFAULT_CATEGORY) {
      return 1
    }
    return left.localeCompare(right)
  })
  const categoryUnion = toTypeUnion(categories)
  const categoryTuple = `[${categories.map((category) => quote(category)).join(', ')}]`
  const categoryLines = categories
    .map((category) => `  ${quote(category)}: ${toTypeUnion(categoryMap.get(category) ?? [])}`)
    .join('\n')

  return `${toHeaderComment(files)}
export type TranslateKey = ${keyUnion}
export type TranslateKeys = TranslateKey
export const TranslationCategories = ${categoryTuple} as const
export type TranslateCategory = ${categoryUnion}
export interface TranslateKeysByCategory {
${categoryLines}
}
export type TranslateKeyOf<C extends TranslateCategory> = TranslateKeysByCategory[C]
export const LanguageCodes = ${languageTuple} as const
export type TranslateLanguage = (typeof LanguageCodes)[number]
`
}

const resolveTypeImportPath = (outputPath: string, outputKeysPath: string): string => {
  const relativePath = relative(dirname(outputPath), outputKeysPath)
  const normalizedPath = relativePath.split('\\').join('/')
  const withPrefix = normalizedPath.startsWith('.') ? normalizedPath : `./${normalizedPath}`
  const extension = extname(withPrefix)
  const withoutExtension =
    extension.length > 0 ? withPrefix.slice(0, -extension.length) : withPrefix
  return `${withoutExtension}.js`
}

const toTableModuleSource = <TLanguage extends string>(
  files: ReadonlyArray<string>,
  records: ReadonlyArray<TranslationRecord<TLanguage>>,
  languages: ReadonlyArray<TLanguage>,
  typeImportPath: string
): string => {
  const recordSource = records
    .map((record) => {
      const languageLines = languages
        .map((language) => `    ${language}: ${quote(record.values[language])},`)
        .join('\n')

      return `  ${quote(record.key)}: {
    category: ${quote(record.category)},
    description: ${quote(record.description)},
${languageLines}
  },`
    })
    .join('\n')

  return `${toHeaderComment(files)}
export const translationTable = {
${recordSource}
} as const

export type {
  TranslateCategory,
  TranslateKey,
  TranslateKeyOf,
  TranslateKeys,
  TranslateKeysByCategory,
  TranslateLanguage
} from ${quote(typeImportPath)}
`
}

interface PreparedGenerationData<TLanguage extends string> {
  files: ReadonlyArray<string>
  records: ReadonlyArray<TranslationRecord<TLanguage>>
}

interface TsOutputPaths {
  outputPath: string
  outputKeysPath: string
}

interface SwiftOutputPaths {
  outputPath: string
}

interface KotlinOutputPaths {
  outputPath: string
}

interface RuntimeBridgeOutputPaths {
  outputPath: string
  bundleOutputPath: string
  mode: RuntimeBridgeMode
  functionName: string
}

interface ResolvedGenerationOutputPaths {
  outputContractPath: string
  ts: TsOutputPaths
  swift?: SwiftOutputPaths
  kotlin?: KotlinOutputPaths
  runtimeBridge?: RuntimeBridgeOutputPaths
}

const resolveInputFiles = async (
  inputPatterns: ReadonlyArray<string>
): Promise<ReadonlyArray<string>> => {
  const fileSet = new Set<string>()
  for (const pattern of inputPatterns) {
    const matches = await glob(pattern, { nodir: true })
    matches.sort().forEach((file) => fileSet.add(file))
  }
  return Array.from(fileSet.values()).sort()
}

const prepareGenerationData = async <TLanguage extends string>(
  config: TypekitI18nConfig<TLanguage>
): Promise<PreparedGenerationData<TLanguage>> => {
  validateLanguageConfig(config)

  const configuredFormat = config.format
  const inputPatterns = Array.isArray(config.input) ? config.input : [config.input]
  const files = await resolveInputFiles(inputPatterns)

  if (files.length === 0) {
    throw new Error(`No translation files matched input pattern(s): ${inputPatterns.join(', ')}`)
  }

  const keySet = new Set<string>()
  const records: TranslationRecord<TLanguage>[] = []
  const errors: string[] = []

  for (const filePath of files) {
    const format = configuredFormat ?? inferInputFormatFromPath(filePath)
    let project: TranslationIrProject<string>
    try {
      project = await loadProjectFromFile(filePath, format, config)
    } catch (error: unknown) {
      errors.push(error instanceof Error ? error.message : String(error))
      continue
    }

    project.entries.forEach((entry, entryIndex) => {
      if (keySet.has(entry.key)) {
        errors.push(
          `Duplicate key "${entry.key}" found in ${toEntryLocation(format, filePath, entryIndex)}.`
        )
        return
      }
      keySet.add(entry.key)
      const values = {} as Record<TLanguage, string>
      let hasLanguageError = false
      config.languages.forEach((language) => {
        const translated = entry.values[language]
        if (typeof translated !== 'string') {
          errors.push(
            `Missing language "${language}" in ${toEntryLocation(format, filePath, entryIndex)}.`
          )
          hasLanguageError = true
          return
        }
        values[language] = translated
      })
      if (hasLanguageError) {
        return
      }
      records.push({
        category: normalizeCategory(entry.category),
        key: entry.key,
        description: entry.description,
        status: entry.status,
        tags: entry.tags,
        placeholders: entry.placeholders,
        values,
      })
    })
  }

  if (errors.length > 0) {
    throw new Error(toCombinedErrorMessage(errors))
  }

  return {
    files,
    records,
  }
}

const resolveGenerationOutputPaths = <TLanguage extends string>(
  config: TypekitI18nConfig<TLanguage>,
  targets: ReadonlyArray<CodegenTarget>
): ResolvedGenerationOutputPaths => {
  const outputPath = resolve(config.output)
  const outputKeysPath = resolve(
    config.outputKeys ?? join(dirname(outputPath), 'translationKeys.ts')
  )
  const outputContractPath = resolve(
    config.outputContract ?? join(dirname(outputPath), 'translation.contract.json')
  )

  if (outputPath === outputKeysPath) {
    throw new Error(
      'Invalid configuration: "output" and "outputKeys" must not point to the same file.'
    )
  }
  if (outputPath === outputContractPath || outputKeysPath === outputContractPath) {
    throw new Error(
      'Invalid configuration: "outputContract" must not point to the same file as "output" or "outputKeys".'
    )
  }

  const includesSwift = targets.includes('swift')
  const includesKotlin = targets.includes('kotlin')
  const includesNativeTargets = includesSwift || includesKotlin
  const shouldGenerateRuntimeBridge =
    includesNativeTargets ||
    typeof config.outputRuntimeBridge === 'string' ||
    typeof config.runtimeBridgeMode === 'string' ||
    typeof config.runtimeBridgeFunctionName === 'string'
  const swiftOutputPath = includesSwift
    ? resolve(config.outputSwift ?? join(dirname(outputPath), 'translation.swift'))
    : null
  const kotlinOutputPath = includesKotlin
    ? resolve(config.outputKotlin ?? join(dirname(outputPath), 'translation.kt'))
    : null
  const runtimeBridgeOutputPath = shouldGenerateRuntimeBridge
    ? resolve(config.outputRuntimeBridge ?? join(dirname(outputPath), 'translation.runtime.mjs'))
    : null
  const runtimeBridgeBundleOutputPath = shouldGenerateRuntimeBridge
    ? resolve(
        config.outputRuntimeBridgeBundle ??
          join(dirname(outputPath), 'translation.runtime.bundle.js')
      )
    : null
  const runtimeBridgeMode = config.runtimeBridgeMode ?? 'icu'
  const runtimeBridgeFunctionName = config.runtimeBridgeFunctionName ?? '__typekitTranslate'

  if (swiftOutputPath && (swiftOutputPath === outputPath || swiftOutputPath === outputKeysPath)) {
    throw new Error(
      'Invalid configuration: "outputSwift" must not point to the same file as "output" or "outputKeys".'
    )
  }
  if (swiftOutputPath && swiftOutputPath === outputContractPath) {
    throw new Error(
      'Invalid configuration: "outputSwift" must not point to the same file as "outputContract".'
    )
  }
  if (
    kotlinOutputPath &&
    (kotlinOutputPath === outputPath || kotlinOutputPath === outputKeysPath)
  ) {
    throw new Error(
      'Invalid configuration: "outputKotlin" must not point to the same file as "output" or "outputKeys".'
    )
  }
  if (kotlinOutputPath && kotlinOutputPath === outputContractPath) {
    throw new Error(
      'Invalid configuration: "outputKotlin" must not point to the same file as "outputContract".'
    )
  }
  if (swiftOutputPath && kotlinOutputPath && swiftOutputPath === kotlinOutputPath) {
    throw new Error(
      'Invalid configuration: "outputSwift" and "outputKotlin" must not point to the same file.'
    )
  }
  if (
    runtimeBridgeOutputPath &&
    (runtimeBridgeOutputPath === outputPath ||
      runtimeBridgeOutputPath === outputKeysPath ||
      runtimeBridgeOutputPath === outputContractPath)
  ) {
    throw new Error(
      'Invalid configuration: "outputRuntimeBridge" must not point to the same file as "output", "outputKeys", or "outputContract".'
    )
  }
  if (
    runtimeBridgeOutputPath &&
    ((swiftOutputPath && runtimeBridgeOutputPath === swiftOutputPath) ||
      (kotlinOutputPath && runtimeBridgeOutputPath === kotlinOutputPath))
  ) {
    throw new Error(
      'Invalid configuration: "outputRuntimeBridge" must not point to the same file as "outputSwift" or "outputKotlin".'
    )
  }
  if (
    runtimeBridgeBundleOutputPath &&
    (runtimeBridgeBundleOutputPath === outputPath ||
      runtimeBridgeBundleOutputPath === outputKeysPath ||
      runtimeBridgeBundleOutputPath === outputContractPath)
  ) {
    throw new Error(
      'Invalid configuration: "outputRuntimeBridgeBundle" must not point to the same file as "output", "outputKeys", or "outputContract".'
    )
  }
  if (
    runtimeBridgeBundleOutputPath &&
    ((swiftOutputPath && runtimeBridgeBundleOutputPath === swiftOutputPath) ||
      (kotlinOutputPath && runtimeBridgeBundleOutputPath === kotlinOutputPath))
  ) {
    throw new Error(
      'Invalid configuration: "outputRuntimeBridgeBundle" must not point to the same file as "outputSwift" or "outputKotlin".'
    )
  }
  if (
    runtimeBridgeOutputPath &&
    runtimeBridgeBundleOutputPath &&
    runtimeBridgeOutputPath === runtimeBridgeBundleOutputPath
  ) {
    throw new Error(
      'Invalid configuration: "outputRuntimeBridge" and "outputRuntimeBridgeBundle" must not point to the same file.'
    )
  }
  if (runtimeBridgeMode !== 'basic' && runtimeBridgeMode !== 'icu') {
    throw new Error(
      `Invalid configuration: "runtimeBridgeMode" must be "basic" or "icu" (received "${runtimeBridgeMode}").`
    )
  }
  if (runtimeBridgeOutputPath && !runtimeBridgeBundleOutputPath) {
    throw new Error('Runtime bridge bundling output path is missing.')
  }
  if (runtimeBridgeFunctionName.trim().length === 0) {
    throw new Error(
      'Invalid configuration: "runtimeBridgeFunctionName" must be a non-empty string.'
    )
  }

  const resolvedRuntimeBridgePaths =
    runtimeBridgeOutputPath && runtimeBridgeBundleOutputPath
      ? {
          outputPath: runtimeBridgeOutputPath,
          bundleOutputPath: runtimeBridgeBundleOutputPath,
          mode: runtimeBridgeMode,
          functionName: runtimeBridgeFunctionName,
        }
      : undefined

  return {
    outputContractPath,
    ts: {
      outputPath,
      outputKeysPath,
    },
    swift: swiftOutputPath
      ? {
          outputPath: swiftOutputPath,
        }
      : undefined,
    kotlin: kotlinOutputPath
      ? {
          outputPath: kotlinOutputPath,
        }
      : undefined,
    runtimeBridge: resolvedRuntimeBridgePaths,
  }
}

interface TsTargetContext<TLanguage extends string> {
  files: ReadonlyArray<string>
  records: ReadonlyArray<TranslationRecord<TLanguage>>
  languages: ReadonlyArray<TLanguage>
  outputPaths: TsOutputPaths
}

const generateTsTarget = async <TLanguage extends string>(
  context: TsTargetContext<TLanguage>
): Promise<GenerateTargetResult> => {
  await Promise.all([
    mkdir(dirname(context.outputPaths.outputPath), { recursive: true }),
    mkdir(dirname(context.outputPaths.outputKeysPath), { recursive: true }),
  ])

  const tableSource = toTableModuleSource(
    context.files,
    context.records,
    context.languages,
    resolveTypeImportPath(context.outputPaths.outputPath, context.outputPaths.outputKeysPath)
  )
  const keysSource = toKeysModuleSource(context.files, context.records, context.languages)

  await Promise.all([
    writeFile(context.outputPaths.outputPath, tableSource, 'utf-8'),
    writeFile(context.outputPaths.outputKeysPath, keysSource, 'utf-8'),
  ])

  return {
    target: 'ts',
    outputPaths: [context.outputPaths.outputPath, context.outputPaths.outputKeysPath],
  }
}

/**
 * Generates canonical contract plus selected target artifacts.
 *
 * @param config Generation configuration.
 * @param options Optional multi-target generation options.
 * @returns Generated target results plus canonical contract output path.
 */
export const generateTranslations = async <TLanguage extends string>(
  config: TypekitI18nConfig<TLanguage>,
  options: GenerateTranslationsOptions = {}
): Promise<GenerateTranslationsResult> => {
  const targets = resolveCodegenTargets(options.targets)
  const prepared = await prepareGenerationData(config)
  const outputPaths = resolveGenerationOutputPaths(config, targets)

  await mkdir(dirname(outputPaths.outputContractPath), { recursive: true })

  const contract: TranslationContract<string> = createTranslationContract({
    sourceLanguage: config.defaultLanguage,
    languages: config.languages,
    localeByLanguage: config.localeByLanguage,
    records: prepared.records,
  })
  const contractSource = toTranslationContractSource(contract)
  await writeFile(outputPaths.outputContractPath, contractSource, 'utf-8')

  const runtimeBridgeResult = outputPaths.runtimeBridge
    ? await generateRuntimeBridgeTarget({
        contract,
        outputPath: outputPaths.runtimeBridge.outputPath,
        mode: outputPaths.runtimeBridge.mode,
        functionName: outputPaths.runtimeBridge.functionName,
      })
    : null
  const runtimeBridgeBundleResult =
    outputPaths.runtimeBridge && runtimeBridgeResult
      ? await bundleRuntimeBridgeTarget({
          inputPath: runtimeBridgeResult.outputPath,
          outputPath: outputPaths.runtimeBridge.bundleOutputPath,
        })
      : null

  const targetResults: GenerateTargetResult[] = []
  for (const target of targets) {
    if (target === 'ts') {
      const result = await generateTsTarget({
        files: prepared.files,
        records: prepared.records,
        languages: config.languages,
        outputPaths: outputPaths.ts,
      })
      targetResults.push(result)
      continue
    }

    if (target === 'swift') {
      if (!outputPaths.swift) {
        throw new Error('Swift generation target is missing resolved output path.')
      }
      const result = await generateSwiftTarget({
        contract,
        outputPath: outputPaths.swift.outputPath,
      })
      targetResults.push({
        target: 'swift',
        outputPaths: [result.outputPath],
      })
      continue
    }

    if (target === 'kotlin') {
      if (!outputPaths.kotlin) {
        throw new Error('Kotlin generation target is missing resolved output path.')
      }
      const result = await generateKotlinTarget({
        contract,
        outputPath: outputPaths.kotlin.outputPath,
      })
      targetResults.push({
        target: 'kotlin',
        outputPaths: [result.outputPath],
      })
      continue
    }
  }

  const formattedTargetOutputs = targetResults.flatMap((result) =>
    result.outputPaths.map((outputPath) => `"${outputPath}"`)
  )
  if (runtimeBridgeResult) {
    formattedTargetOutputs.push(`"${runtimeBridgeResult.outputPath}"`)
  }
  if (runtimeBridgeBundleResult) {
    formattedTargetOutputs.push(`"${runtimeBridgeBundleResult.outputPath}"`)
  }
  const outputSummary =
    formattedTargetOutputs.length > 0
      ? `${formattedTargetOutputs.join(', ')}, and "${outputPaths.outputContractPath}"`
      : `"${outputPaths.outputContractPath}"`

  process.stdout.write(
    `${pc.green(
      `Generated ${outputSummary} with ${prepared.records.length} keys (targets: ${targets.join(', ')}).`
    )}\n`
  )

  return {
    keyCount: prepared.records.length,
    outputContractPath: outputPaths.outputContractPath,
    targets,
    targetResults,
    runtimeBridgePath: runtimeBridgeResult?.outputPath,
    runtimeBridgeBundlePath: runtimeBridgeBundleResult?.outputPath,
  }
}

/**
 * Generates typed TypeScript table outputs and canonical contract artifact.
 *
 * @param config Generation configuration.
 * @returns Absolute output paths and number of generated keys.
 */
export const generateTranslationTable = async <TLanguage extends string>(
  config: TypekitI18nConfig<TLanguage>
): Promise<{
  outputPath: string
  outputKeysPath: string
  outputContractPath: string
  keyCount: number
}> => {
  const result = await generateTranslations(config, {
    targets: ['ts'],
  })
  const tsResult = result.targetResults.find((targetResult) => targetResult.target === 'ts')

  if (!tsResult || tsResult.outputPaths.length !== 2) {
    throw new Error('TypeScript target did not return expected output artifacts.')
  }

  return {
    outputPath: tsResult.outputPaths[0],
    outputKeysPath: tsResult.outputPaths[1],
    outputContractPath: result.outputContractPath,
    keyCount: result.keyCount,
  }
}
